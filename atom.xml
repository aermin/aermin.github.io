<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hxvin的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-09T05:17:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hxvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue2的todolist入门小项目的详细解析</title>
    <link href="http://yoursite.com/2017/05/09/vue2%E7%9A%84todolist%E5%85%A5%E9%97%A8%E5%B0%8F%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/05/09/vue2的todolist入门小项目的详细解析/</id>
    <published>2017-05-09T05:08:49.000Z</published>
    <updated>2017-05-09T05:17:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>看完vue2的官方文档后，找个入门项目巩固下知识点，简单的todolsit是个不错的选择。<br>项目用到了<code>vue.js</code> <code>vue.cli</code> <code>webpack</code> <code>ES6</code> <code>node环境</code>，完成项目后会对这些技术栈有了些了解。</p>
<h3 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h3><ul>
<li>$ npm install -g vue-cli </li>
<li>$ vue init <template-name> <project-name></project-name></template-name></li>
<li>如 vue innit webpack todolist</li>
<li>$ cd todolist</li>
<li>$ npm install</li>
<li>$ npm run dev</li>
<li>安装谷歌插件vue.js devtools</li>
<li>下载vue.js的<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">webpack模板</a></li>
<li>下载 <a href="https://github.com/tastejs/todomvc-app-template" target="_blank" rel="external">todomvc的模板</a><br>（也可以直接$ git clone <a href="https://github.com/tastejs/todomvc-app-template.git" target="_blank" rel="external">https://github.com/tastejs/todomvc-app-template.git</a> 来下载）</li>
<li>把todomvc的index.html拖到todolist文件夹去覆盖里面的index.html</li>
<li>打开todomvc的json文件，会看到 “todomvc-app-css”: “^2.0.0”,就是要你 npm  install todomvc-app-css -S 从而下载该css</li>
<li>删点todolsit index.html的默认css，js引用，src文件夹下的main.js引入模板css（import‘todomvc-app-css/index.css’）</li>
<li>引入vue（import Vue form ‘vue’）</li>
</ul>
<h3 id="main-js的代码"><a href="#main-js的代码" class="headerlink" title="main.js的代码"></a>main.js的代码</h3><blockquote>
<p>//后面的为注释讲解， ~表示串联index.html的对应内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">import &apos;todomvc-app-css/index.css&apos;</div><div class="line"></div><div class="line">import Vue from &apos;vue&apos;</div><div class="line"></div><div class="line"></div><div class="line">//用过滤器筛选出三种状态</div><div class="line">var filters = &#123;</div><div class="line">  all(todos) &#123;</div><div class="line">    return todos</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  active(todos) &#123;</div><div class="line">    return todos.filter((todo) =&gt; &#123;</div><div class="line">      return !todo.completed</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  completed(todos) &#123;</div><div class="line">    return todos.filter((todo) =&gt; &#123;</div><div class="line">      return todo.completed</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">let app = new Vue(&#123;</div><div class="line">  el: &apos;.todoapp&apos;,    // ~ &lt;section class=&quot;todoapp&quot;&gt;</div><div class="line">  data: &#123;</div><div class="line">    msg: &apos;hello world&apos;,</div><div class="line">    title: &apos;待做清单&apos;,   // 渲染标题 ~ &#123;&#123;title&#125;&#125;</div><div class="line">    newTodo: &apos;&apos;,</div><div class="line">    todos: [&#123;   // ~ v-show=&quot;todos.length&quot; ； ~ &#123;&#123;todos.length&gt;1?&apos;items&apos;:&apos;item&apos;&#125;&#125; </div><div class="line">      content: &apos;下午：读完“追风筝的人”&apos;,  // 渲染 li ~  v-for=&quot;(todo,index) in filteredTodos&quot; </div><div class="line">      completed: false</div><div class="line">    &#125;, &#123;</div><div class="line">      content: &apos;晚上：写读书笔记&apos;,</div><div class="line">      completed: false</div><div class="line">    &#125;],</div><div class="line">    editedTodo: &apos;&apos;,   // 空的编辑对象</div><div class="line">    hashName: &apos;all&apos;    </div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    remain() &#123;</div><div class="line">      return filters.active(this.todos).length   //未完成事项的数量 ~ &#123;&#123;remain&#125;&#125;</div><div class="line">    &#125;, </div><div class="line">    isAll: &#123;     // ~ v-model=&quot;isAll&quot;</div><div class="line">      get() &#123;</div><div class="line">        return this.remain === 0</div><div class="line">      &#125;,</div><div class="line">      set(value) &#123;</div><div class="line">        this.todos.forEach((todo) =&gt; &#123;</div><div class="line">          todo.completed = value</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    filteredTodos() &#123;    //用hashName过滤出当前页面的todos  ~ v-for=&quot;(todo,index) in filteredTodos&quot; </div><div class="line">      return filters[this.hashName](this.todos)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  methods: &#123;</div><div class="line">    addTodo(e) &#123;  //输入值为空时，不添加（trim去除前后空格） ~ v-model.trim=&quot;newTodo&quot; </div><div class="line">      if (!this.newTodo) &#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      this.todos.push(&#123;</div><div class="line">        content: this.newTodo,</div><div class="line">        completed: false //结合v-model 根据completed状态绑定样式  ~:class=&quot;&#123;completed:todo.completed； ~ v-model=&quot;todo.completed&quot;</div><div class="line">      &#125;)</div><div class="line">      this.newTodo = &apos;&apos;</div><div class="line">    &#125;,</div><div class="line">    removeTodo(index) &#123;   //绑定x样式，点击删除该todo ~ @click=&quot;removeTodo(index)&quot;</div><div class="line">      this.todos.splice(index, 1)</div><div class="line">    &#125;,</div><div class="line">    editTodo(todo) &#123;         //编辑 ~ @dblclick=&quot;editTodo(todo)&quot;</div><div class="line">      this.editCache = todo.content //储存编辑前的内容</div><div class="line">      this.editedTodo = todo  // 点击编辑里面的内容而不是只是空文本框~ editing:todo==editedTodo&#125;&quot;</div><div class="line">    &#125;,</div><div class="line">    doneEdit(todo, index) &#123;  //失去焦点后 ~ @blur=&quot;doneEdit(todo)&quot;；@keyup.enter=&quot;doneEdit(todo)&quot;</div><div class="line">      this.editedTodo = null  //不存在编辑了或者说编辑已完成</div><div class="line">      if (!todo.content) &#123;  //如果编辑后没有内容了，删除该todo</div><div class="line">        this.removeTodo(index)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    cancelEdit(todo) &#123;    //按esc键取消此次编辑操作 ~ @keyup.esc=&quot;cancelEdit(todo)&quot;&gt;</div><div class="line">      this.editedTodo = null     </div><div class="line">      todo.content = this.editCache //当esc取消编辑时，还原编辑前的内容</div><div class="line">    &#125;,</div><div class="line">    clear() &#123;  //点击清除已完成的功能 ~ @click=&quot;clear&quot;</div><div class="line">      this.todos = filters.active(this.todos)  //获取并渲染未完成的事项 ~ </div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  directives: &#123;   //自定义属性 ~ v-focus=&quot;todo == editedTodo&quot;</div><div class="line">    focus(el, value) &#123;  //文本框双击获取焦点</div><div class="line">      if (value) &#123;</div><div class="line">        el.focus()</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//hash（url地址中#以及之后的字符）</div><div class="line">function hashChange() &#123; </div><div class="line">// ~ :class=&quot;&#123;selected:hashName==&apos;all&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;active&apos;&#125;&quot;；:class=&quot;&#123;selected:hashName==&apos;completed&apos;&#125;&quot;</div><div class="line">  let hashName = location.hash.replace(/#\/?/, &apos;&apos;)  //正则表达式去除#/？，获取如all，active，completed</div><div class="line">  if (filters[hashName]) &#123;   //如果过滤状态的hashName存在</div><div class="line">    app.hashName = hashName  //给整个app变量里的hashName赋上那个值</div><div class="line">  &#125; else &#123;</div><div class="line">    location.hash = &apos;&apos;    //取消</div><div class="line">    app.hashName = &apos;all&apos;  //否则就赋值‘all’，回到全部事项的页面</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.addEventListener(&apos;hashchange&apos;, hashChange) //全局监听hash</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完vue2的官方文档后，找个入门项目巩固下知识点，简单的todolsit是个不错的选择。&lt;br&gt;项目用到了&lt;code&gt;vue.js&lt;/code&gt; &lt;code&gt;vue.cli&lt;/code&gt; &lt;code&gt;webpack&lt;/code&gt; &lt;code&gt;ES6&lt;/code&gt; &lt;cod
    
    </summary>
    
    
      <category term="-vue2 -项目总结" scheme="http://yoursite.com/tags/vue2-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yoursite.com/2017/04/29/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/04/29/冒泡排序/</id>
    <published>2017-04-29T09:46:44.000Z</published>
    <updated>2017-04-29T09:46:44.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻松学习JS快速排序(QuickSort)</title>
    <link href="http://yoursite.com/2017/04/29/%E8%BD%BB%E6%9D%BE%E5%AD%A6%E4%B9%A0JS%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort/"/>
    <id>http://yoursite.com/2017/04/29/轻松学习JS快速排序-QuickSort/</id>
    <published>2017-04-29T03:32:03.000Z</published>
    <updated>2017-04-29T03:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需了解的基础知识"><a href="#需了解的基础知识" class="headerlink" title="需了解的基础知识"></a>需了解的基础知识</h3><p> 1.递归函数：编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。<br> <code>一个典型阶乘递归函数：</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function fact(num)&#123; </div><div class="line">   if (num&lt;=1)&#123; </div><div class="line">   return 1; </div><div class="line">   &#125;else&#123; </div><div class="line">   return num*fact(num-1); </div><div class="line">&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> <code>该函数的弊端：</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var another=factorical;</div><div class="line">factorical=null;</div><div class="line">console.log(another(2))//会报错说 factorical not a function</div></pre></td></tr></table></figure></p>
<p> <code>解决方法</code>: 用arguments.callee去代替函数名，就可以确保函数不管怎么调用都不会出错。</p>
 <a id="more"></a>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function factorical(num)&#123;</div><div class="line">　　if(num&lt;=1)&#123;</div><div class="line">　　　　return 1;</div><div class="line">　　&#125;</div><div class="line">　　else&#123;</div><div class="line">　　　　return num*arguments.callee(num-1);</div><div class="line">　　&#125;</div><div class="line">&#125;</div><div class="line">var another=factorical;</div><div class="line">factorical=null;</div><div class="line">console.log(another(2))//2</div></pre></td></tr></table></figure>
<p> (来自js高程)<br> 2.<a href="http://www.jb51.net/article/88894.htm" target="_blank" rel="external">JavaScript中的splice方法用法详解</a><br> 3.<a href="http://www.w3school.com.cn/jsref/jsref_concat_array.asp" target="_blank" rel="external">JavaScript concat()方法</a><br> 3.<a href="http://www.jb51.net/article/86083.htm" target="_blank" rel="external">Javascript之Math对象详解</a></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>以下内容整理自<code>阮一峰老师</code>的<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="external">快速排序（Quicksort）的Javascript实现</a></p>
<blockquote>
<p>首先，定义一个quickSort函数，它的参数是一个数组。</p>
</blockquote>
<p>var quickSort = function(arr) { </p>
<blockquote>
<p>然后，检查数组的元素个数，如果小于等于1，就返回。</p>
</blockquote>
<p>　　if (arr.length &lt;= 1) { return arr; } 
　　</p>
<blockquote>
<p>接着，选择”基准”（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。<code>splice返回的是数组,用[0]返回值</code></p>
</blockquote>
<p>　　var pivotIndex = Math.floor(arr.length / 2);<br>　　var pivot = arr.splice(pivotIndex, 1)[0];<br>　　var left = [];<br>　　var right = [];
　　</p>
<blockquote>
<p>然后，开始遍历数组，小于”基准”的元素放入左边的子集，大于基准的元素放入右边的子集。</p>
</blockquote>
<p>　　for (var i = 0; i &lt; arr.length; i++){<br>　　　　if (arr[i] &lt; pivot) {<br>　　　　　　left.push(arr[i]);<br>　　　　} else {<br>　　　　　　right.push(arr[i]);<br>　　　　}<br>　　}
　　</p>
<blockquote>
<p>最后，使用递归不断重复这个过程，就可以得到排序后的数组。</p>
</blockquote>
<p>　　return quickSort(left).concat([pivot], quickSort(right));<br>};</p>
<blockquote>
<p>使用的时候，直接调用quickSort()就行了。</p>
</blockquote>
<h3 id="最终的快排函数"><a href="#最终的快排函数" class="headerlink" title="最终的快排函数"></a>最终的快排函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var quickSort = function(arr) &#123;</div><div class="line">　　if (arr.length &lt;= 1) &#123; return arr; &#125;</div><div class="line">　　var pivotIndex = Math.floor(arr.length / 2);</div><div class="line">　　var pivot = arr.splice(pivotIndex, 1)[0];</div><div class="line">　　var left = [];</div><div class="line">　　var right = [];</div><div class="line">　　for (var i = 0; i &lt; arr.length; i++)&#123;</div><div class="line">　　　　if (arr[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(arr[i]);</div><div class="line">　　　　&#125; else &#123;</div><div class="line">　　　　　　right.push(arr[i]);</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　return quickSort(left).concat([pivot], quickSort(right));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="实例运用"><a href="#实例运用" class="headerlink" title="实例运用"></a>实例运用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var array = [7,4,1,9,6,3,2,5,8] ;</div><div class="line">quickSort(array); //输出1，2，3，4，5，6，7，8，9</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;需了解的基础知识&quot;&gt;&lt;a href=&quot;#需了解的基础知识&quot; class=&quot;headerlink&quot; title=&quot;需了解的基础知识&quot;&gt;&lt;/a&gt;需了解的基础知识&lt;/h3&gt;&lt;p&gt; 1.递归函数：编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。&lt;br&gt; &lt;code&gt;一个典型阶乘递归函数：&lt;/code&gt;&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function fact(num)&amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   if (num&amp;lt;=1)&amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return 1; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;else&amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   return num*fact(num-1); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;该函数的弊端：&lt;/code&gt;&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var another=factorical;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;factorical=null;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;console.log(another(2))//会报错说 factorical not a function&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;解决方法&lt;/code&gt;: 用arguments.callee去代替函数名，就可以确保函数不管怎么调用都不会出错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>开发中js数组的常用方法</title>
    <link href="http://yoursite.com/2017/04/27/%E5%BC%80%E5%8F%91%E4%B8%ADjs%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/04/27/开发中js数组的常用方法/</id>
    <published>2017-04-27T05:03:14.000Z</published>
    <updated>2017-04-27T11:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>在ES5中，一共有9个Array方法：</li>
</ul>
<p>Array.prototype.indexOf;<br>Array.prototype.lastIndexOf;<br>Array.prototype.every;<br>Array.prototype.some;<br>Array.prototype.forEach;<br>Array.prototype.map;<br>Array.prototype.filter;<br>Array.prototype.reduce;<br>Array.prototype.reduceRight;</p>
<p>5种比较常用=&gt;index(),filter(),forEach(),map(),reduce().</p>
<blockquote>
<p>ps:reduce()还没搞懂，就先不整理了。<br>文末有个实例了解实际运用。</p>
</blockquote>
<a id="more"></a>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="1-indexOf"><a href="#1-indexOf" class="headerlink" title="1) indexOf"></a>1) indexOf</h4><p>indexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。<br>不使用indexOf时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],</div><div class="line">found = false;</div><div class="line"> </div><div class="line">for(var i= 0, l = arr.length; i&lt; l; i++)&#123;</div><div class="line">if(arr[i] === &apos;a&apos;)&#123;</div><div class="line">found = true;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">console.log(&quot;found:&quot;,found);//输出found: true</div></pre></td></tr></table></figure>
<ul>
<li>indexOf使用后</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</div><div class="line"> </div><div class="line">console.log(&quot;found:&quot;, arr.indexOf(&quot;a&quot;) != -1);//输出found: true</div></pre></td></tr></table></figure>
<h4 id="2-filter"><a href="#2-filter" class="headerlink" title="2) filter"></a>2) filter</h4><p>该filter()方法创建一个新的匹配过滤条件的数组。</p>
<ul>
<li>不用 filter() 时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var arr = [</div><div class="line">  [&quot;a&quot;, 2],</div><div class="line">  [&quot;b&quot;, 5],</div><div class="line">  [&quot;c&quot;, 3],</div><div class="line">  [&quot;b&quot;, 16],</div><div class="line">];</div><div class="line">   </div><div class="line">var newArr = [];</div><div class="line"> </div><div class="line">for(var i= 0, l = arr.length; i&lt; l; i++)&#123;</div><div class="line">  if(arr[i][0] == &quot;b&quot; )&#123;</div><div class="line">newArr.push(arr[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(newArr);//输出b,5,b,16</div></pre></td></tr></table></figure>
<ul>
<li>用了 filter():</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr = [</div><div class="line">  [&quot;a&quot;, 2],</div><div class="line">  [&quot;b&quot;, 5],</div><div class="line">  [&quot;c&quot;, 3],</div><div class="line">  [&quot;b&quot;, 16],</div><div class="line">];</div><div class="line">  var newArr = arr.filter(function(element, index, array)&#123;</div><div class="line">  return element[0] == &quot;b&quot; ;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">alert(newArr); //输出b,5,b,16</div></pre></td></tr></table></figure>
<h4 id="3-forEach"><a href="#3-forEach" class="headerlink" title="3) forEach()"></a>3) forEach()</h4><p>forEach为每个元素执行对应的方法,用来替换for循环</p>
<ul>
<li>不用 forEach() 时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5,6,7,8];</div><div class="line">for(var i= 0, l = arr.length; i&lt; l; i++)&#123;</div><div class="line">console.log(arr[i]); //输出 1 2 3 4 5 6 7 8 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>用了forEach()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5,6,7,8];</div><div class="line">arr.forEach(function(element, index, array)&#123;</div><div class="line">console.log(element);//输出 1 2 3 4 5 6 7 8 </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="4-map"><a href="#4-map" class="headerlink" title="4) map()"></a>4) map()</h4><p>map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组，<br>不使用map<br>map()是处理服务器返回数据时是一个非常实用的函数。</p>
<ul>
<li>不用 map() 时</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;];</div><div class="line"> </div><div class="line">function getNewArr()&#123;</div><div class="line">   </div><div class="line">  var newArr = [];</div><div class="line">   </div><div class="line">  for(var i= 0, l = oldArr.length; i&lt; l; i++)&#123;</div><div class="line">    var item = oldArr[i];</div><div class="line">    full_name = [item.first_name,item.last_name].join(&quot; &quot;);</div><div class="line">    newArr[i] = full_name;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  return newArr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">console.log(getNewArr());//输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;]</div></pre></td></tr></table></figure>
<ul>
<li>使用map后</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var oldArr = [&#123;first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;&#125;,&#123;first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;&#125;,&#123;first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;&#125;];</div><div class="line"> </div><div class="line">function getNewArr()&#123;</div><div class="line">     </div><div class="line">  return oldArr.map(function(item,index)&#123;</div><div class="line">    full_name = [item.first_name,item.last_name].join(&quot; &quot;);</div><div class="line">    return full_name;</div><div class="line">  &#125;);</div><div class="line">   </div><div class="line">&#125;</div><div class="line"> </div><div class="line">console.log(getNewArr());  //输出 [&quot;Colin Toh&quot;, &quot;Addy Osmani&quot;, &quot;Yehuda Katz&quot;]</div></pre></td></tr></table></figure>
<h3 id="百度IFE的js任务-二-的运用"><a href="#百度IFE的js任务-二-的运用" class="headerlink" title="百度IFE的js任务(二)的运用"></a>百度IFE的js任务(二)的运用</h3><p><a href="http://ife.baidu.com/course/detail/id/91" target="_blank" rel="external">传送门</a><br>任务描述:参考以下示例代码，页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上</p>
<p>实现思路：<br>1、用filter()方法筛选出值大于60的城市赋值给一个新的数组。<br>2、用sort()对这个新的数组进行由大到小的排序。<br>3、用forEach()代替for循环并动态创建li标签并打印名次和城市及其空气质量值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;IFE JavaScript Task 01&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">  &lt;h3&gt;污染城市列表&lt;/h3&gt;</div><div class="line">  &lt;ul id=&quot;aqi-list&quot;&gt;</div><div class="line">&lt;!--   </div><div class="line">    &lt;li&gt;第一名：福州（样例），10&lt;/li&gt;</div><div class="line">      &lt;li&gt;第二名：福州（样例），10&lt;/li&gt; --&gt;</div><div class="line">  &lt;/ul&gt;</div><div class="line"></div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line"></div><div class="line">var aqiData = [</div><div class="line">  [&quot;北京&quot;, 90],</div><div class="line">  [&quot;上海&quot;, 50],</div><div class="line">  [&quot;福州&quot;, 10],</div><div class="line">  [&quot;广州&quot;, 50],</div><div class="line">  [&quot;成都&quot;, 90],</div><div class="line">  [&quot;西安&quot;, 100]</div><div class="line">];</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line"></div><div class="line">  /*</div><div class="line">  在注释下方编写代码</div><div class="line">  遍历读取aqiData中各个城市的数据</div><div class="line">  将空气质量指数大于60的城市显示到aqi-list的列表中</div><div class="line">  */</div><div class="line">   var aqiul=document.getElementById(&apos;aqi-list&apos;); //获取数组</div><div class="line"></div><div class="line"> //用filter()方法筛选出空气质量指数大于60的数组</div><div class="line">   var filtered = aqiData.filter(function(element, index, array)&#123;</div><div class="line">      return (element[1] &gt;= 60);</div><div class="line">    &#125;) ;</div><div class="line"></div><div class="line">   filtered.sort(function(a,b)&#123; //从大到小排序</div><div class="line">      return b[1]-a[1];</div><div class="line">  &#125;);</div><div class="line">   </div><div class="line">  //    (function wirte()&#123;    //输出  用for循环</div><div class="line">  //   for(var i=0;i&lt;filtered.length;i++)&#123;</div><div class="line">  //     var li=document.createElement(&apos;li&apos;);</div><div class="line">  //     aqiul.append(li);</div><div class="line">  //     li.innerHTML=&quot;第&quot;+(i+1)+&quot;名：&quot;+filtered[i];</div><div class="line">  //   &#125;</div><div class="line">  // &#125;)();</div><div class="line"></div><div class="line">//用forEach方法代替for循环</div><div class="line"> filtered.forEach(function(element, index, array)&#123;</div><div class="line">      var li=document.createElement(&apos;li&apos;);</div><div class="line">         aqiul.append(li);</div><div class="line">         li.innerHTML=&quot;第&quot;+(index+1)+&quot;名：&quot;+filtered[index];</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在ES5中，一共有9个Array方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Array.prototype.indexOf;&lt;br&gt;Array.prototype.lastIndexOf;&lt;br&gt;Array.prototype.every;&lt;br&gt;Array.prototype.some;&lt;br&gt;Array.prototype.forEach;&lt;br&gt;Array.prototype.map;&lt;br&gt;Array.prototype.filter;&lt;br&gt;Array.prototype.reduce;&lt;br&gt;Array.prototype.reduceRight;&lt;/p&gt;
&lt;p&gt;5种比较常用=&amp;gt;index(),filter(),forEach(),map(),reduce().&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps:reduce()还没搞懂，就先不整理了。&lt;br&gt;文末有个实例了解实际运用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于自执行函数（立即执行函数）</title>
    <link href="http://yoursite.com/2017/04/26/%E5%85%B3%E4%BA%8E%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%88%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/26/关于自执行函数（立即执行函数）/</id>
    <published>2017-04-26T15:42:12.000Z</published>
    <updated>2017-04-26T15:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是自执行函数？"><a href="#什么是自执行函数？" class="headerlink" title="什么是自执行函数？"></a>什么是自执行函数？</h3><p>一下有三种写法</p>
<p>1.最前最后加括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function()&#123;alert(1);&#125;());</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如：</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a=1 </div><div class="line">(function()&#123;alert(1);&#125;());</div></pre></td></tr></table></figure>
<p>2.function外面加括号 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function()&#123;alert(1);&#125;)();</div></pre></td></tr></table></figure>
<blockquote>
<p>这种做法比方法1少了一个代码整体性的好处.</p>
</blockquote>
<p>3.function前面加运算符，常见的是!与void 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">!function()&#123;alert(1);&#125;(); </div><div class="line">void function()&#123;alert(2);&#125;();</div></pre></td></tr></table></figure>
<blockquote>
<p>显然，加上“!”或“+”等运算符，写起来是最简单的。加上“void ”要敲五下键盘，但是听说有一个好处是，比加”!”少一次逻辑运算。</p>
</blockquote>
<p><img src="http://images2015.cnblogs.com/blog/336056/201610/336056-20161011221635859-1560145581.png" alt="自执行函数"></p>
<ul>
<li>首先声明一个匿名函数 function(){alert(‘我是匿名函数’)}。</li>
<li>然后在匿名函数后面接一对括号 ()，调用这个匿名函数。</li>
</ul>
<h3 id="自执行函数的作用"><a href="#自执行函数的作用" class="headerlink" title="自执行函数的作用"></a>自执行函数的作用</h3><p>创建一个独立的作用域，这个作用域里面的变量，外面访问不到（即避免「变量污染」）</p>
<p>例子来看一个著名的面试题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var liList = ul.getElementsByTagName(&apos;li&apos;)</div><div class="line">for(var i=0; i&lt;6; i++)&#123;</div><div class="line">  liList[i].onclick = function()&#123;</div><div class="line">    alert(i) // 为什么 alert 出来的总是6,而不是0、1、2、3、4、5</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 为什么 alert 的总是 6 呢?</p>
<blockquote>
<p>因为 i 是贯穿整个作用域的，而不是给每个li 分配了一个i,如下：</p>
</blockquote>
<p><img src="http://images2015.cnblogs.com/blog/336056/201610/336056-20161011221647906-1355610620.png" alt="也是网上的图"></p>
<p> 那么怎么解决这个问题呢？</p>
<blockquote>
<p>用立即执行函数给每个li创造一个独立作用域即可（当然还有其他办法）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var liList = ul.getElementsByTagName(&apos;li&apos;)</div><div class="line">for(var i=0; i&lt;6; i++)&#123;</div><div class="line">  !function(ii)&#123;</div><div class="line">    liList[ii].onclick = function()&#123;</div><div class="line">      alert(ii) // 0、1、2、3、4、5</div><div class="line">    &#125;</div><div class="line">  &#125;(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在立即执行函数执行的时候，i 的值被赋值给 ii，此后 ii 的值一直不变。i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。</p>
</blockquote>
<p>(整理自网络)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是自执行函数？&quot;&gt;&lt;a href=&quot;#什么是自执行函数？&quot; class=&quot;headerlink&quot; title=&quot;什么是自执行函数？&quot;&gt;&lt;/a&gt;什么是自执行函数？&lt;/h3&gt;&lt;p&gt;一下有三种写法&lt;/p&gt;
&lt;p&gt;1.最前最后加括号&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(function()&amp;#123;alert(1);&amp;#125;());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种方法好处是能提醒阅读代码的人，这段代码是一个整体。 坏处是前面的代码行后记得加分号，不然会报错。如：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于this对象的一个易错点</title>
    <link href="http://yoursite.com/2017/04/26/%E5%85%B3%E4%BA%8Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9/"/>
    <id>http://yoursite.com/2017/04/26/关于this对象的一个易错点/</id>
    <published>2017-04-26T15:39:31.000Z</published>
    <updated>2017-04-26T15:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先给一个例子"><a href="#先给一个例子" class="headerlink" title="先给一个例子"></a>先给一个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    </div><div class="line">    f1 : function()&#123;</div><div class="line">       return function()&#123;</div><div class="line">           return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">  alert(object.f1()());</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>这个例子返回的字符串是 “The Window”，为啥不是”My Object”呢？</p>
</blockquote>
<ul>
<li>原因是每个函数在被调用时， 其活动对象都会自动取得两个特殊变量：<code>this</code>和<code>arguments</code>。内部函数在搜索这两个变最时， 只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</li>
<li>也就是说要想让闭包【return function(){}】访问到外部函数【f1 :function(){}】里的this（或者arguments）变量，就要先将其赋值给到一个闭包能够访问到的变量里，如var that = this，这样就可以了。</li>
</ul>
<h4 id="修改后的例子如下"><a href="#修改后的例子如下" class="headerlink" title="修改后的例子如下"></a>修改后的例子如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;,</div><div class="line">    </div><div class="line">    f1 : function()&#123;</div><div class="line">       var that = this; //添加这行</div><div class="line">       return function()&#123;</div><div class="line">           return this.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">  alert(object.f1()());</div></pre></td></tr></table></figure>
<blockquote>
<p>返回”My Object”</p>
</blockquote>
<h4 id="另外一个例子"><a href="#另外一个例子" class="headerlink" title="另外一个例子"></a>另外一个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window•;</div><div class="line">var object = &#123;</div><div class="line">    name : &quot;My Object&quot;;</div><div class="line">    getName: function() &#123;</div><div class="line">         return this.name;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>上一个例子中的<br>return function(){<br>    return this.name；<br>}<br>被换掉了，不再是闭包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object.getName(); //&apos;My Object&apos;</div><div class="line">(object.getName)(); //&apos;My Object&quot;</div><div class="line">(object.getName = object.getNamel (); //&quot;The Window•, 在非严格模式下</div></pre></td></tr></table></figure>
<blockquote>
<p>第一行代码跟平常一样词用了object.getName (), 返回的是飞y Object”, 因为this.name<br>就是object.name。第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后， 就好􀉀只<br>是在引用一个函数， 但this的值得到了维持， 因为objec七.getName 和(object.getName)的定义<br>是相同的。第三行代码先执行了一条赋值语句，然后再诮用赋值后的结果。因为这个赋值表达式的值是<br>函数本身， 所以this的值不能得到维持， 结果就返回了崎The Window飞</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;先给一个例子&quot;&gt;&lt;a href=&quot;#先给一个例子&quot; class=&quot;headerlink&quot; title=&quot;先给一个例子&quot;&gt;&lt;/a&gt;先给一个例子&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name = &amp;quot;The Window&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var object = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name : &amp;quot;My Object&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    f1 : function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       return function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           return this.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  alert(object.f1()());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计(二)</title>
    <link href="http://yoursite.com/2017/04/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/04/25/面向对象的程序设计-二/</id>
    <published>2017-04-25T12:36:34.000Z</published>
    <updated>2017-04-25T13:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="OO语言中支持两种继承方式：实现继承，接口继承"><a href="#OO语言中支持两种继承方式：实现继承，接口继承" class="headerlink" title="OO语言中支持两种继承方式：实现继承，接口继承"></a>OO语言中支持两种继承方式：实现继承，接口继承</h3><ul>
<li>实现继承：继承实际的方法  </li>
<li>接口继承：继承函数签名  </li>
</ul>
<h4 id="由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的"><a href="#由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的" class="headerlink" title="由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的"></a>由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的</h4><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="http://ooytyiziz.bkt.clouddn.com/7895A860-4021-47A7-A343-BBC78A970381.png" alt="原型链"></p>
<a id="more"></a>
<h4 id="原型链的问题（缺点）"><a href="#原型链的问题（缺点）" class="headerlink" title="原型链的问题（缺点）"></a>原型链的问题（缺点）</h4><ul>
<li>1、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题）  </li>
<li>2、在创建子类型的实例时，不能向超类型的构造函数中传递参数  </li>
</ul>
<h4 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h4><ul>
<li>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。  </li>
</ul>
<h4 id="如何确定原型和实例之间的关系"><a href="#如何确定原型和实例之间的关系" class="headerlink" title="如何确定原型和实例之间的关系"></a>如何确定原型和实例之间的关系</h4><ul>
<li>1、通过instanceof:测试实例与原型链中出现过的构造函数，结果会返回true  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	   alert(instance instanceof Object)    //true  </div><div class="line">		alert(instance instanceof SuperType)    //true  </div><div class="line">		alert(instance instanceof Subtype)    //true  </div><div class="line">```  </div><div class="line">* 2、isPropertyOf()方法：只要是原型链中出现过的原型，都会返回true</div><div class="line"></div><div class="line">```  </div><div class="line">	    alert(Object.prtotype.isPropertyOf(instance))    //true  </div><div class="line">		alert(SuperType.prtotype.isPropertyOf(instance))    //true  </div><div class="line">		alert(Subtype.prtotype.isPropertyOf(instance))    //true</div></pre></td></tr></table></figure>
<h4 id="定义方法时要注意的几个问题"><a href="#定义方法时要注意的几个问题" class="headerlink" title="定义方法时要注意的几个问题"></a>定义方法时要注意的几个问题</h4><ul>
<li>场景：子类型优势需要覆盖超类型中的某个方法，或者需要添加类型中不存在的某个方法  </li>
<li>2、不能通过对象字面量方法添加新方法（因为会重写原型链）  </li>
<li>1、给子类型添加方法的代码一定要放在替换原型的语句之后（否则会因为重新定义了原型而导致添加代码无效）  </li>
</ul>
<h4 id="基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法"><a href="#基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法" class="headerlink" title="基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法"></a>基本思想：利用原型，让一个引用类型继承另一个引用类型的属性和方法</h4><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;  </div><div class="line">    this.SuperProperty = true;  </div><div class="line">&#125;;  </div><div class="line">SuperType.prototype.getSuperProperty = function()&#123;return this.SuperProperty&#125;;  </div><div class="line">  </div><div class="line">function SubType()&#123;  </div><div class="line">    this.SubProperty = false;  </div><div class="line">&#125;;  </div><div class="line">SubType.prototype = new SuperType();  </div><div class="line">SubType.prototype.getSubProperty = function()&#123;return this.getSubProperty&#125;;  </div><div class="line">  </div><div class="line">var instance = new SubType();  </div><div class="line">alert(instance.getSuperProperty()) //true</div></pre></td></tr></table></figure>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>1、方法都在构造函数中定义，函数无法复用，每个方法都是function的一个新实例  </li>
<li>2、在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式  </li>
</ul>
<h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><ul>
<li>优点：借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  function SuperType (name) &#123;function   </div><div class="line">	this.name= name;  </div><div class="line">	&#125;  </div><div class="line">	function SubType () &#123;  </div><div class="line">	//继承了Super&apos;l&apos;ype, 同时还传递了参数  </div><div class="line">	superType.call(this, &quot;Nicholas&quot;);  </div><div class="line">	//实例属性  </div><div class="line">	this.age= 29;&#125;  </div><div class="line">	var instance= new SubType();  </div><div class="line">	alert(instance.name) ; //“Nicholas” alert(instance.age); //29  </div><div class="line">	</div><div class="line">```  </div><div class="line">#### 基本思想：在子类型构造函数中调用超类型构造函数  </div><div class="line"></div><div class="line">```  </div><div class="line">    function SuperType()&#123;  </div><div class="line">    this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]      </div><div class="line">&#125;;  </div><div class="line">function SubType()&#123;  </div><div class="line">    SuperType.call(this);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li>1、将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，又叫伪经典继承  </li>
<li>2、基本思想：使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承  </li>
<li>3.是JavaScript中最常用的继承模式  </li>
</ul>
<h4 id="优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性"><a href="#优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性" class="headerlink" title="优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性"></a>优点：既通过在原型上定义方法实现了函数的复用，又能够保证每个实例都有它自己的属性</h4><h4 id="组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式"><a href="#组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式" class="headerlink" title="组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式"></a>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为javascript中最常用的继承模式</h4><h4 id="function-SuperType-name"><a href="#function-SuperType-name" class="headerlink" title="function SuperType(name){"></a>function SuperType(name){</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    this.name = name;  </div><div class="line">    this.color = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]  </div><div class="line">&#125;;  </div><div class="line">SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;;  </div><div class="line">function SubType(name)&#123;  </div><div class="line">    SuperType.call(this,name);  </div><div class="line">    this.age = age;  </div><div class="line">&#125;;  </div><div class="line">SubType.prototype = new SuperType();  </div><div class="line">SubType.prototype.constructor = SubType;  </div><div class="line">SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;;  </div><div class="line"></div><div class="line">```  </div><div class="line">### 原型式继承  </div><div class="line">  </div><div class="line">#### Object.creat()  </div><div class="line">  </div><div class="line">* 参数一  </div><div class="line">	* 用作新对象原型的对象 </div><div class="line"></div><div class="line">``` </div><div class="line">	 var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;;  </div><div class="line">		var anotherPerson =Object.create(person);  </div><div class="line">```  </div><div class="line">* 参数二  </div><div class="line">	* 为新对象定义额外属性的对象（以这种方式指定的任何属性都会覆盖原型对象上的同名属性），注意格式</div><div class="line">	</div><div class="line">```  </div><div class="line">	   var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;;  </div><div class="line">		var anotherPerson =Object.create(person,&#123;  </div><div class="line">		    name:&#123;  </div><div class="line">		    value:&quot;Greg&quot;  </div><div class="line">		    &#125;  </div><div class="line">		&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>ECMAScipt5通过新增的Object.create()规范化了原型式继承  </li>
</ul>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;  </div><div class="line">    function F()&#123;&#125;;  </div><div class="line">    F.prototype = o;  </div><div class="line">    return new F();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name:&quot;Nick&quot; ,friends:[&quot;Tom&quot;,&quot;Sam&quot;]&#125;;  </div><div class="line">var anotherPerson =object(person);  </div><div class="line">//person成为了anotherPerson的原型</div></pre></td></tr></table></figure>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><h4 id="寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。"><a href="#寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。" class="headerlink" title="寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。"></a>寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</h4><h4 id="缺点：不能实现函数复用"><a href="#缺点：不能实现函数复用" class="headerlink" title="缺点：不能实现函数复用"></a>缺点：不能实现函数复用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function creatAnother(original)&#123;  </div><div class="line">    var clone = object(original);  </div><div class="line">    clone.sayHi = function()&#123;alert(&quot;Hi&quot;)&#125;;  </div><div class="line">    return clone;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。"><a href="#在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。" class="headerlink" title="在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。"></a>在主要考虑对象而不是自定义类型和构造函数的悄况下，寄生式继承也是一种有用的模式。</h4><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><h4 id="所谓寄生组合式继承，即通过借用构造函数来继承属性，-通过原型链的混成形式来继承方法。"><a href="#所谓寄生组合式继承，即通过借用构造函数来继承属性，-通过原型链的混成形式来继承方法。" class="headerlink" title="所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。"></a>所谓寄生组合式继承，即通过借用构造函数来继承属性， 通过原型链的混成形式来继承方法。</h4><h4 id="基本思路：-不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。"><a href="#基本思路：-不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。" class="headerlink" title="基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。"></a>基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</h4><h4 id="目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题"><a href="#目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题" class="headerlink" title="目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题"></a>目的：解决组合继承模式中调用两次超类型构造函数，导致属性重写，影响性能的问题</h4><ul>
<li>组合继承例子：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;  //超类型构造函数  </div><div class="line">	    this.name=name;  </div><div class="line">	    this.color=&#123;&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]  </div><div class="line">	  &#125;  </div><div class="line">	 SuperType.prototype.sayName=function()&#123;  </div><div class="line">	 alert(this.name);  </div><div class="line">	 function SubType(name,age)&#123;  </div><div class="line">	     SuperType.call(this,name) //第二次调用  </div><div class="line">	     this.age = age;  </div><div class="line">	 &#125;  </div><div class="line">	 SubType.prototype = new SuperType(); //第一次调用  </div><div class="line">	 SubType.prototype.construtor =SuperType;  </div><div class="line">	 SubType.protptype.sayAge =function()&#123;  </div><div class="line">	     alert(this.age)</div></pre></td></tr></table></figure>
<h4 id="这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变"><a href="#这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变" class="headerlink" title="这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变"></a>这个例子高效体现在它只调用了一次SuperType的构造函数，并且避免了再prototype上创建不必要的、多余的属性。同时还能保证原型链不变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">   function inheritPrototype(subType,superType)&#123;  </div><div class="line">    //prototype成为superType的一个副本，而不用调用构造函数  </div><div class="line">    var prototype = SuperType.prototype;  </div><div class="line">    prototype.constructor = SubType;  </div><div class="line">    SubType.prototype = prototype;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;  </div><div class="line">    this.name = name;  </div><div class="line">&#125;;  </div><div class="line">SuperType.prototype.sayName = function()&#123;alert(this.name)&#125;;  </div><div class="line">function SubType(name,age)&#123;  </div><div class="line">    SuperType.call(this,name);  </div><div class="line">    this.age = age;  </div><div class="line">&#125;  </div><div class="line">inheritPrototype(Subtype,SuperType);  </div><div class="line">SubType.prototype.sayAge = function()&#123;alert(this.age)&#125;;  </div><div class="line"></div><div class="line">    function inheritPrototype(SubType，SuperType)&#123;   </div><div class="line">      var prototype = object(SuperType.prototype);//创建对象  </div><div class="line">     prototype.constructor = subType;//增强对象  </div><div class="line">      subType.prototype = prototype ;//指定对象  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor屈性，从而弥补因重写原型而失去的默认的constructor属性。最后一步， 将新创建的对象（即副本）赋值给子类型的原型。  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;h3 id=&quot;OO语言中支持两种继承方式：实现继承，接口继承&quot;&gt;&lt;a href=&quot;#OO语言中支持两种继承方式：实现继承，接口继承&quot; class=&quot;headerlink&quot; title=&quot;OO语言中支持两种继承方式：实现继承，接口继承&quot;&gt;&lt;/a&gt;OO语言中支持两种继承方式：实现继承，接口继承&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实现继承：继承实际的方法  &lt;/li&gt;
&lt;li&gt;接口继承：继承函数签名  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&quot;&gt;&lt;a href=&quot;#由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&quot; class=&quot;headerlink&quot; title=&quot;由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&quot;&gt;&lt;/a&gt;由于函数没有签名，在ECMAScript中只支持实现继承，而且是依靠原型链来实现的&lt;/h4&gt;&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ooytyiziz.bkt.clouddn.com/7895A860-4021-47A7-A343-BBC78A970381.png&quot; alt=&quot;原型链&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>添加畅言评论</title>
    <link href="http://yoursite.com/2017/04/25/%E6%B7%BB%E5%8A%A0%E7%95%85%E8%A8%80%E8%AF%84%E8%AE%BA/"/>
    <id>http://yoursite.com/2017/04/25/添加畅言评论/</id>
    <published>2017-04-24T16:48:36.000Z</published>
    <updated>2017-04-24T17:01:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="多说评论听说要关闭了，大家都在找评论系统替换。"><a href="#多说评论听说要关闭了，大家都在找评论系统替换。" class="headerlink" title="多说评论听说要关闭了，大家都在找评论系统替换。"></a>多说评论听说要关闭了，大家都在找评论系统替换。</h4><h4 id="我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。"><a href="#我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。" class="headerlink" title="我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。"></a>我搜索对比了大家的解决方式，最终选择了畅言评论，可以用qq，微博，手机登录，还算可以，后台功能也挺好的。</h4><h4 id="而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。"><a href="#而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。" class="headerlink" title="而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。"></a>而且有小伙伴对畅言评论需要备案这件事望而却步，我试了下，其能实挺快搞定的。</h4><blockquote>
<p>步骤教程写在简书上了，就不搬过来啦</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/5888bd91d070" target="_blank" rel="external">简书</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;多说评论听说要关闭了，大家都在找评论系统替换。&quot;&gt;&lt;a href=&quot;#多说评论听说要关闭了，大家都在找评论系统替换。&quot; class=&quot;headerlink&quot; title=&quot;多说评论听说要关闭了，大家都在找评论系统替换。&quot;&gt;&lt;/a&gt;多说评论听说要关闭了，大家都在找评
    
    </summary>
    
    
      <category term="-其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>justjavac的知乎live听后总结</title>
    <link href="http://yoursite.com/2017/04/23/justjavac%E7%9A%84%E7%9F%A5%E4%B9%8Elive%E5%90%AC%E5%90%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/23/justjavac的知乎live听后总结/</id>
    <published>2017-04-23T00:11:12.000Z</published>
    <updated>2017-04-24T15:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>get点：</strong></p>
<blockquote>
<p>1.跟别人互相review代码。<br>2.系统学习js。多写算法相关的，少写特效。如写一个计算器。<br>3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。<br>4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>5.面试官会根据你写在简历里的东西提问。<br>6.远离外包公司（三个月的经验五年的重复），职业生涯中技术难成长。<br>7.扎实基础再去学框架<br>8.移动端不用jQuery<br>9.与其做很多项目，不如做精一个两项目。<br>10.面试考察点：应届生：基础知识，程序员思维，代码规范；社招：解决问题能力。<br>11.对于学习，首选是看书，系统的全面的学。<br>推荐的书：<br>《黑客与画家》<br>《javascript高级程序设计》<br>《javascript精粹》<br>《你不知道的javascript》<br>推荐的网站：MDN<br>等等。。。。。很多</p>
</blockquote>
<p><strong><em>讲了四个小时，jjc大神好敬业，内容很丰盛，很详细，很值得去购买了听~~</em></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;get点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.跟别人互相review代码。&lt;br&gt;2.系统学习js。多写算法相关的，少写特效。如写一个计算器。&lt;br&gt;3.学习不止前端的东西，前端工程师是个程序员，要具备程序员的基础知识能力。&lt;br&gt;4.不要只会拷贝粘贴网上的代码而没有学会其中的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="-学习总结" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>第一次笔试，整理(1)</title>
    <link href="http://yoursite.com/2017/04/18/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%AC%94%E8%AF%95%EF%BC%8C%E6%95%B4%E7%90%86-1/"/>
    <id>http://yoursite.com/2017/04/18/第一次笔试，整理-1/</id>
    <published>2017-04-18T10:11:12.000Z</published>
    <updated>2017-04-25T12:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了.</strong></p>
<a id="more"></a>
<blockquote>
<p>特别想提的一点是在过程中感觉到美图的HR和技术总监为人很 <code>nice</code>，~(≧▽≦)/~赞。**</p>
</blockquote>
<p><strong>这几天都在考期中考，所以笔试完也没马上做总结就去准备接下去接连一天一科的期中考了。</strong></p>
<p><strong><em>笔试有要求题目不能外泄，以下只是自己依稀记得的不大会做，不会做的知识点，仅供补缺补漏使用。</em></strong></p>
<h3 id="1-CSS的某些样式是具有继承性的"><a href="#1-CSS的某些样式是具有继承性的" class="headerlink" title="1.CSS的某些样式是具有继承性的"></a>1.CSS的某些样式是具有继承性的</h3><p><strong>什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。</strong></p>
<blockquote>
<p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。（注：基本上什么盒子外边距、内边距，还有定位什么的是不能被继承的）<br>所有元素可继承：visibility和cursor。<br>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。<br>终端块状元素可继承：text-indent和text-align。<br>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。<br>表格元素可继承：border-collapse。</p>
</blockquote>
<!-- more -->
<h3 id="2-对象的深拷贝与浅拷贝的区别"><a href="#2-对象的深拷贝与浅拷贝的区别" class="headerlink" title="2.对象的深拷贝与浅拷贝的区别"></a>2.对象的深拷贝与浅拷贝的区别</h3><blockquote>
<p>浅拷贝：仅仅复制对象的引用，而不是对象本身；<br>深拷贝：把复制的对象所引用的全部对象都复制一遍。</p>
</blockquote>
<p><strong>浅拷贝例子：</strong></p>
<figure class="highlight plain"><figcaption><span>================ 浅拷贝 ================ */</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">function simpleClone(initalObj) &#123;</div><div class="line">    var obj = &#123;&#125;;</div><div class="line">    for ( var i in initalObj) &#123;</div><div class="line">        obj[i] = initalObj[i];</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">客户端调用</div><div class="line">/* ================ 客户端调用 ================ */</div><div class="line">var obj = &#123;</div><div class="line">    a: &quot;hello&quot;,</div><div class="line">    b: &#123;</div><div class="line">        a: &quot;world&quot;,</div><div class="line">        b: 21</div><div class="line">    &#125;,</div><div class="line">    c: [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;],</div><div class="line">    d: function() &#123;</div><div class="line">        alert(&quot;hello world&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var cloneObj = simpleClone(obj); // 对象拷贝</div><div class="line"> </div><div class="line">console.log(cloneObj.b); // &#123;a: &quot;world&quot;, b: 21&#125;</div><div class="line">console.log(cloneObj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;]</div><div class="line">console.log(cloneObj.d); // function() &#123; alert(&quot;hello world&quot;); &#125;</div><div class="line"> </div><div class="line">// 修改拷贝后的对象</div><div class="line">cloneObj.b.a = &quot;changed&quot;;</div><div class="line">cloneObj.c = [1, 2, 3];</div><div class="line">cloneObj.d = function() &#123; alert(&quot;changed&quot;); &#125;;</div><div class="line"> </div><div class="line">console.log(obj.b); // &#123;a: &quot;changed&quot;, b: 21&#125; // // 原对象所引用的对象被修改了</div><div class="line"> </div><div class="line">console.log(obj.c); // [&quot;Bob&quot;, &quot;Tom&quot;, &quot;Jenny&quot;] // 原对象所引用的对象未被修改</div><div class="line">console.log(obj.d); // function() &#123; alert(&quot;hello world&quot;); &#125; // 原对象所引用的函数未被修改</div></pre></td></tr></table></figure>
<p><strong>深拷贝的实现也有很多种方法，这里就介绍Object.create()方法</strong></p>
<figure class="highlight plain"><figcaption><span>================ 深拷贝 ================ */</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function deepClone(initalObj, finalObj) &#123;</div><div class="line">    var obj = finalObj || &#123;&#125;;</div><div class="line">    for (var i in initalObj) &#123;</div><div class="line">        var prop = initalObj[i];</div><div class="line">        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</div><div class="line">        if(prop === obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        if (typeof prop === &apos;object&apos;) &#123;</div><div class="line">            obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);</div><div class="line">        &#125; else &#123;</div><div class="line">            obj[i] = prop;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;之前就关注了美图招聘的公众号，忽然惊喜地看到美图的春招，有招暑假的实习生，我匆忙制作了第一个自己的前端简历，然后投了，很惊喜地收到美图的笔试通知，然后隔天就要笔试了😂，之前都没做过面试的相关准备，也只能临时匆忙准备了.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="-笔试 -美图" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95-%E7%BE%8E%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计(-)</title>
    <link href="http://yoursite.com/2017/04/18/js%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/04/18/js面对对象/</id>
    <published>2017-04-17T16:11:12.000Z</published>
    <updated>2017-04-25T13:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数"><a href="#定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数" class="headerlink" title="定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数"></a>定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数</h4><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><ul>
<li>数据属性  <ul>
<li>[[Configurabke]]:能否通过delete删除属性从而重新定义属性  </li>
</ul>
</li>
<li>访问器属性  </li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="可以通过“构造函数”或者“对象字面量”方法创建函数"><a href="#可以通过“构造函数”或者“对象字面量”方法创建函数" class="headerlink" title="可以通过“构造函数”或者“对象字面量”方法创建函数"></a>可以通过“构造函数”或者“对象字面量”方法创建函数</h4><ul>
<li>缺点：通过一个接口创建很多对象，会产生大量的重复代码  </li>
</ul>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> function creatPerson(name,age,job)&#123;  </div><div class="line">    var o=new Object();  </div><div class="line">    o.name=name;  </div><div class="line">    o.age=age;  </div><div class="line">    o.job=job;  </div><div class="line">    return o  </div><div class="line">&#125;                                                                        </div><div class="line"> var person1 = creatPerson(“hxvin”,21,”F-E”);</div></pre></td></tr></table></figure>
<ul>
<li>用函数来封装以特定接口创建对象的细节  </li>
<li>缺点：没有解决对象识别的问题  </li>
</ul>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">    this.age=age;  </div><div class="line">    this.job=job;  </div><div class="line">    this.sayName=function sayName()&#123;alert(this.name);&#125;;  </div><div class="line">&#125;;  </div><div class="line">var person1=new Person(“hxvin”,21,&quot;Front-end-Engineer&quot;);</div></pre></td></tr></table></figure>
<ul>
<li>和工厂模式的区别：  <ul>
<li>没有显式的创建对象  </li>
<li>直接将属性和方法赋给了this  </li>
<li>没有return语句  </li>
</ul>
</li>
<li>用这种方式调用构造函数会经历一下四个步骤  <ul>
<li>执行构造函数中的代码（为这个新对象添加属性）  </li>
<li>创建一个新对象  </li>
<li>将构造函数的作用域赋给新对象  </li>
<li>返回新对象  </li>
</ul>
</li>
<li><p>缺点：每个方法都要在每个实例上创建一遍  </p>
<ul>
<li><p>上例中sayName方法相当于</p>
<blockquote>
<p>this.sayName=new Funciton(“alert(name,age,job)”)  </p>
</blockquote>
</li>
<li><p>解决方法  </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;  </div><div class="line">    this.name=name;  </div><div class="line">    this.age=age;  </div><div class="line">    this.job=job;  </div><div class="line">    this.sayName=sayName  </div><div class="line">&#125;;  </div><div class="line">function sayName()&#123;alert(this.name);&#125;;  </div><div class="line">//将sayName添加到全局变量中，这样显然有很多不足</div></pre></td></tr></table></figure>
<ul>
<li>原型模式  </li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ul>
<li><p>概念  </p>
<ul>
<li><p>每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以<br>  由特定类型的所有实例共享的属性和方法  </p>
</li>
<li><p>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法  </p>
</li>
<li>创建原型:</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  function Person()&#123;&#125;;  </div><div class="line">Person.prototype.name=“hxvin”；  </div><div class="line">Person.prototype.sayname=function()&#123; alert(this.name);  &#125;；                         </div><div class="line">var person1=new Person();                                   </div><div class="line">person1.dayName(); //“hxvin”</div></pre></td></tr></table></figure>
<ul>
<li>理解原型  <ul>
<li>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个protoype属性，这个属性指向函数的原型对象。  </li>
<li>在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，包含一个指向prototype属性所在函数的指针  </li>
<li>搜索流程  <ul>
<li>当对象实例中与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性会屏蔽原型中的属性  </li>
<li>每当代码读取某个对象属性时，先从实例中搜索，后在原型对象中查找  </li>
<li>hasOwnProperty()  <ul>
<li>用来检查一个属性时存在于对象实例中还是原型中，这个方法只在给定属性存在于对象实例中时，才会返回true  </li>
<li>alert(person1 hasOwnProperty(“name”));       //返回true或false  </li>
</ul>
</li>
</ul>
</li>
<li>[[prototype]]  <ul>
<li>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象  </li>
<li>利用[[prototype]]  <ul>
<li>ECMAScript5增加了一个新方法，叫Object.getPropertyOf(),在所有支持的实现中，这个方法返回[[prototype]]的值  <ul>
<li>支持的浏览器：IE9+,FireFox3.5+,Safari 3.5+,Opera12+,Chrome  </li>
</ul>
</li>
<li>但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系  <ul>
<li>alert(Person.protoype isPrototypeOf(person1));   //true  </li>
</ul>
</li>
<li>没有标准的方式访问[[prototype]]  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>更简单的原型语法 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> //可以重新设置constructor  </div><div class="line">function Perspn()&#123;&#125;;  </div><div class="line">Person.prototype=&#123;  </div><div class="line">    constructor=Person,  </div><div class="line">    name=&quot;Nick&quot;  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line"> function Person()&#123;&#125;;  </div><div class="line">Person.prototype=&#123;  </div><div class="line">    name=&quot;Nick&quot;,  </div><div class="line">    sayName=function()&#123;alert(this.name)&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注意！！！！constructor属性不再指向Person了，我们在这里使用的语法本质上完全重写了默认的prototype对象，因此现在的constructor指向Object构造函数  <ul>
<li>原型的动态性  </li>
<li>注意：如果把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系（因为改变了[[prototype]]指针）  </li>
<li>我们对原型对象所做的任何修改都能够立即从实例上反映出来  </li>
<li>原型对象的问题（缺点）  </li>
<li>1、省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值  </li>
<li>2、当在实例中对引用类型的值进行操作时，很有可能改变原型中的值。（共享问题）  <ul>
<li>由于friends 数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2. friends (与person2.friends指向同一个数组反映出来  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;  </div><div class="line">    this.name=name,  </div><div class="line">    this.age=age,  </div><div class="line">    this.job=job  </div><div class="line">&#125;;  </div><div class="line">Person.prototype=&#123;  </div><div class="line">    constructor=Person,  </div><div class="line">    sayName=function()&#123;alert(this.name)&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Person1.friends不会影响到Person2.friends，因为它们分别引用了不同的数组  <ul>
<li>优点  </li>
<li>每个实例都会有自己的一份实例属性副本，但同时由共享着对方法的引用，最大限度的节省了内存  </li>
<li>创建自定义类型最常见的方式  </li>
<li>支持向构造函数传递参数  </li>
</ul>
</li>
</ul>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;          //属性  </div><div class="line">    this.name=name;  </div><div class="line">    this.age=age;  </div><div class="line">    this.job=job;  </div><div class="line">    //方法  </div><div class="line">    if(typeof sayName != &quot;function&quot;)&#123;  </div><div class="line">        Person.prototype.sayName = function()&#123;alert(this.name)&#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>//方法中，只在sayName()方法不存在的清况下，才会将它添加到原型中。<br> 这里对原型所做的修改，能够立即在所有实例中得到反映。  </p>
</blockquote>
<ul>
<li>把所有信息封装在构造函数中，并通过if语句初始化原型  </li>
</ul>
<h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> function Person(name,age,job)&#123;  </div><div class="line">    var o = new Object();  </div><div class="line">    o.name = name;  </div><div class="line">    o.age = age;  </div><div class="line">    o.job = job;  </div><div class="line">    o.sayName = function()&#123;alert(o.name)&#125;;  </div><div class="line">    return o  </div><div class="line">&#125;;  </div><div class="line">var person1 = new Person();</div></pre></td></tr></table></figure>
<ul>
<li>应用场景：创建有额外方法的特殊对象，而又不想改变其原有的构造函数  </li>
<li>特点  <ul>
<li>返回的对象和构造函数没有关系  </li>
<li>不能依赖instanceof操作符来确定对象类型  </li>
</ul>
</li>
</ul>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><ul>
<li>所谓稳妥对象，指的是没有公共属性， 而且其方法也不引用this的对象。  </li>
</ul>
<pre><code>function Person(name,age,job){  
      var o = new Object();  
      o.sayName = function(){alert(name)}  
  }  

  var friend = Person (“hxvin”,”21”,”f-e”);  
      friend.sayName(}; //“hxvin”
</code></pre><blockquote>
<p>这样，变蜇person 中保存的是一个稳妥对象， 而除了调用sayName() 方法外,没有别的方式可以访问其数据成员。  </p>
</blockquote>
<ul>
<li>这种模式创建的对象中，出了使用sayName()方法之外，没有其他任何办法访问name的值。  </li>
<li>应用场景： 一些安全的环境中（这些环境中会禁止使用this和new), 或者在防止数据被其他应用程序（如Mashup程序）改动时使用  </li>
<li>特点：遵循与寄生构造函数类似的模式，但有两点不同： 一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h3&gt;&lt;h4 id=&quot;定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&quot;&gt;&lt;a href=&quot;#定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&quot; class=&quot;headerlink&quot; title=&quot;定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&quot;&gt;&lt;/a&gt;定义：对象是无序属性集合，其属性可以包含基本值、对象或者函数&lt;/h4&gt;&lt;h4 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数据属性  &lt;ul&gt;
&lt;li&gt;[[Configurabke]]:能否通过delete删除属性从而重新定义属性  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问器属性  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;h4 id=&quot;可以通过“构造函数”或者“对象字面量”方法创建函数&quot;&gt;&lt;a href=&quot;#可以通过“构造函数”或者“对象字面量”方法创建函数&quot; class=&quot;headerlink&quot; title=&quot;可以通过“构造函数”或者“对象字面量”方法创建函数&quot;&gt;&lt;/a&gt;可以通过“构造函数”或者“对象字面量”方法创建函数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;缺点：通过一个接口创建很多对象，会产生大量的重复代码  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h4&gt;
    
    </summary>
    
    
      <category term="-学习笔记 -JavaScript" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaScript/"/>
    
  </entry>
  
</feed>
